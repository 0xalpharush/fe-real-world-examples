
use std::traits::{Min, Max}
use raw_call::{RawCallHelper, MemoryEncoding}
use interfaces::ERC20

// Poor man's interfaces
// FIXME: We can not move this because it triggers the ingot impl check but I think it's a bug here
pub contract ISwapRouter {
    pub fn exactInputSingle(self, params: ExactInputSingleParams) -> u256 {
        revert
    }
}

pub struct ExactInputSingleParams {
    pub tokenIn: address
    pub tokenOut: address
    pub fee: u16
    pub recipient: address
    pub deadline: u256
    pub amountIn: u256
    pub amountOutMinimum: u256
    pub sqrtPriceLimitX96: u128
}

impl MemoryEncoding for ExactInputSingleParams {

    fn write_mem(self) {
        self.abi_encode()
    }

    fn byte_count(self) -> u16 {
        return 256
    }
}


// For this example, we will set the pool fee to 0.3%.
const poolFee: u16 = 3000

contract SwapExamples {

    swapRouter: ISwapRouter

    DAI: ERC20
    WETH9: ERC20

    pub fn __init__(mut self, _swapRouter: ISwapRouter) {
        self.swapRouter = _swapRouter;
        // TODO: allow addresses to be used as module constants
        self.DAI = ERC20(address(0x6B175474E89094C44Da98b954EedeAC495271d0F))
        self.WETH9 = ERC20(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2))
    }

    pub fn swap_exact_input_single(mut self, mut ctx: Context, amountIn: u256) -> u256 {
        // msg.sender must approve this contract

        // Transfer the specified amount of DAI to this contract.
        //TransferHelper.safeTransferFrom(DAI, msg.sender, address(this), amountIn);
        self.DAI.transferFrom(ctx, sender: ctx.msg_sender(), recipient: ctx.self_address(), value: amountIn)
        

        // // Approve the router to spend DAI.
        // //TransferHelper.safeApprove(DAI, address(swapRouter), amountIn);
        self.DAI.approve(ctx, spender: address(self.swapRouter), value: amountIn)


        // // Naively set amountOutMinimum to 0. In production, use an oracle or other data source to choose a safer value for amountOutMinimum.
        // // We also set the sqrtPriceLimitx96 to be 0 to ensure we swap our exact input amount.
        
         let params: ExactInputSingleParams = ExactInputSingleParams(
             tokenIn: address(self.DAI),
             tokenOut: address(self.WETH9),
             fee: 3000,
             recipient: ctx.msg_sender(),
             deadline: ctx.block_timestamp(),
             amountIn: amountIn,
             amountOutMinimum: 0,
             sqrtPriceLimitX96: 0,
         );

        unsafe {
            return self.handle_swap(params)
        }
    }

    pub unsafe fn handle_swap(self, params: ExactInputSingleParams) -> u256 {
        // FIXME: something wrong with resolving generics on RawCallHelper::call
        let raw_call_helper: RawCallHelper = RawCallHelper()
        raw_call_helper.call(address(self.swapRouter), 0x414bf389, data: params)

        // Caller has to handle the return data manually. This could be nicer if Fe allowed function
        // return types to be generic.
        let output: u256 = RawCallHelper::avail()
        let output_size: u256 = std::evm::return_data_size()
        std::evm::return_data_copy(to_offset: output, from_offset: 0, len: output_size)
        let ret: u256 = std::evm::mload(offset: output)
        return ret
    }

}

